{
  "hash": "550fd60e050076a75f4e765e2798f0b7",
  "result": {
    "markdown": "---\ntitle: \"파이썬 프로그래밍\"\ndescription: \"데이터 과학을 위한 프로그래밍을 배워봅니다.\"\ndate: today # 날짜 설정: now, last-modified\nauthor:\n  - name: 이광춘\n    affiliation: TCS\ntitle-block-banner: false\nformat:\n  html:\n    theme: \n      - flatly\n      - css/quarto-fonts.css\n    code-fold: false\n    code-overflow: scroll\n    toc: true\n    toc-depth: 3\n    number-sections: true\n    highlight-style: github    \n    self-contained: false\neditor_options: \n  chunk_output_type: console\nknitr:\n  opts_chunk: \n    collapse: true\n    comment: \"#>\" \n    R.options:\n      knitr.graphics.auto_pdf: true  \nfilters:\n   - lightbox\nlightbox: auto      \n---\n\n\n# 정규화\n\n파이썬 정규화 함수를 작성하고 이를 통해 정규분포 난수에서 나온 표본을 표준정규분포로 정규화하는 코드.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np \n\n# 정규분포에서 나온 난수\nmu, sigma = 100, 10 \n\nrandom_samples = np.random.normal(mu, sigma, size = 10)\n\n# 정규화 값을 저장\nresults = []\n\n# 정규화 함수\ndef normalize(sample):\n  return( (sample - mu) / sigma)\n\n# 정규화\nfor sample in random_samples:\n    results.append( normalize(sample) )\n\nprint(results)\n#> [-0.37082741498345084, 0.8656631990371195, -0.18901873427866747, 0.82126547785832, -1.829051157694846, -0.533750732400371, -0.6976763280348308, -0.14691958971619384, 0.03463514277669048, -1.5771028398960425]\n```\n:::\n\n\n# 벡터화\n\n**벡터화(Vectorization)**는 데이터 과학에서 크게 두가지 점에서 중요하다. \n\n- 루프 반복문을 돌리는 대신 전체 배열과 행렬에 연산작업을 수행하여 속도를 높임. 특히 데이터가 큰 경우 큰 효과를 볼 수 있음. 대체로 Vectorization은 C 혹은 포트란으로 작성됨.\n- 동일한 작업을 벡터화 코드로 작성하게 되면 가독성을 크게 높이고 코드가 간결해지는 장점이 있음.\n\n:::{.panel-tabset}\n\n## for 루프 작성\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\n# 배열 두개를 생성\nA_arr = np.array([1, 2, 3, 4, 5])\nB_arr = np.array([6, 7, 8, 7, 8])\n\n# 최종 결과 저장\nresult_arr = []\n\n# 각 배열 항목별로 연산작업을 수행\nfor i in range(len(A_arr)):\n    result_arr.append(A_arr[i] + B_arr[i])\n\nprint(result_arr)\n#> [7, 9, 11, 11, 13]\n```\n:::\n\n\n\n## 벡터화 코드\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\n# 배열 두개를 생성\nA_arr = np.array([1, 2, 3, 4, 5])\nB_arr = np.array([6, 7, 8, 7, 8])\n\n# 벡터화 연산\nresult_arr = A_arr + B_arr\n\nprint(result_arr)\n#> [ 7  9 11 11 13]\n```\n:::\n\n\n:::\n\n\n# 제곱 방법\n\n다양한 방식으로 데이터에 함수 (제곱)를 적용시켜 보자.\n\n:::{.panel-tabset}\n\n## `for` 루프\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsamples = [1, 2, 3, 4, 5]\nsquared_samples = []\n\nfor sample in samples:\n    squared_samples.append(sample**2)\n    \nsquared_samples\n#> [1, 4, 9, 16, 25]\n```\n:::\n\n\n## list comprehension\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsamples = [1, 2, 3, 4, 5]\nsquared_samples = [x**2 for x in samples]\nsquared_samples\n#> [1, 4, 9, 16, 25]\n```\n:::\n\n\n## 생성자(generator)\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsamples = (1, 2, 3, 4, 5)\nsquared_samples = (x**2 for x in samples)\nlist(squared_samples)\n#> [1, 4, 9, 16, 25]\n```\n:::\n\n\n## `map()` 함수\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsamples = [1, 2, 3, 4, 5]\nsquared_samples = list(map(lambda x: x**2, samples))\nsquared_samples\n#> [1, 4, 9, 16, 25]\n```\n:::\n\n\n## `numpy` 배열\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsamples_arr = np.array([1, 2, 3, 4, 5])\nsquared_samples = samples_arr ** 2\nsquared_samples\n# print(squared_samples)\n#> array([ 1,  4,  9, 16, 25])\n```\n:::\n\n\n## pandas 데이터프레임\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\nsamples = [1, 2, 3, 4, 5]\n\ndf = pd.DataFrame(samples, columns=[\"samples\"])\ndf[\"squared_numbers\"] = df[\"samples\"].apply(lambda x: x**2)\nprint(df)\n#>    samples  squared_numbers\n#> 0        1                1\n#> 1        2                4\n#> 2        3                9\n#> 3        4               16\n#> 4        5               25\n```\n:::\n\n\n:::\n\n# `gapminder` 데이터셋\n\n## 사용자 정의 함수\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n\ndf = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})\n\n# 제곱함수\ndef square(x):\n    return x**2\n\n# A 칼럽에 사용자 정의 함수를 적용\ndf['A_squared'] = df['A'].apply(square)\n\nprint(df)\n#>    A  B  A_squared\n#> 0  1  4          1\n#> 1  2  5          4\n#> 2  3  6          9\n```\n:::\n\n\n\n## `apply()` 함수\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\nfrom gapminder import gapminder\n\ngapminder['GDP'] = gapminder.apply(lambda row: row['pop'] * row['gdpPercap'] / 10**9, axis=1)\n\ngapminder[['country', 'pop', 'gdpPercap', 'GDP']]\n#>           country       pop   gdpPercap       GDP\n#> 0     Afghanistan   8425333  779.445314  6.567086\n#> 1     Afghanistan   9240934  820.853030  7.585449\n#> 2     Afghanistan  10267083  853.100710  8.758856\n#> 3     Afghanistan  11537966  836.197138  9.648014\n#> 4     Afghanistan  13079460  739.981106  9.678553\n#> ...           ...       ...         ...       ...\n#> 1699     Zimbabwe   9216418  706.157306  6.508241\n#> 1700     Zimbabwe  10704340  693.420786  7.422612\n#> 1701     Zimbabwe  11404948  792.449960  9.037851\n#> 1702     Zimbabwe  11926563  672.038623  8.015111\n#> 1703     Zimbabwe  12311143  469.709298  5.782658\n#> \n#> [1704 rows x 4 columns]\n```\n:::\n\n\n\n## 사용자 정의 함수\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\nfrom gapminder import gapminder\nfrom functools import partial\n\ndef calculate_gdp(row):\n  return(row['pop'] * row['gdpPercap'] / 10**9)\n\ngapminder['GDP'] = gapminder.apply(calculate_gdp, axis=1)\n\ngapminder[['country', 'pop', 'gdpPercap', 'GDP']]\n#>           country       pop   gdpPercap       GDP\n#> 0     Afghanistan   8425333  779.445314  6.567086\n#> 1     Afghanistan   9240934  820.853030  7.585449\n#> 2     Afghanistan  10267083  853.100710  8.758856\n#> 3     Afghanistan  11537966  836.197138  9.648014\n#> 4     Afghanistan  13079460  739.981106  9.678553\n#> ...           ...       ...         ...       ...\n#> 1699     Zimbabwe   9216418  706.157306  6.508241\n#> 1700     Zimbabwe  10704340  693.420786  7.422612\n#> 1701     Zimbabwe  11404948  792.449960  9.037851\n#> 1702     Zimbabwe  11926563  672.038623  8.015111\n#> 1703     Zimbabwe  12311143  469.709298  5.782658\n#> \n#> [1704 rows x 4 columns]\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}