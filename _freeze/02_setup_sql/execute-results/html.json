{
  "hash": "e0139cd8be152d89f2c86dc91e6817f5",
  "result": {
    "markdown": "---\ntitle: \"SQL 환경설정\"\ndescription: \"데이터 과학 SQL 데이터베이스 환경설정을 준비합니다.\"\ndate: today # 날짜 설정: now, last-modified\nauthor:\n  - name: 이광춘\n    affiliation: TCS\ntitle-block-banner: false\nformat:\n  html:\n    css: css/quarto-fonts.css\n    code-fold: false\n    toc: true\n    toc-depth: 2\n    number-sections: true\n    highlight-style: github    \n    self-contained: false\nbibliography: bibliography.bib\nlink-citations: yes\ncsl: apa-single-spaced.csl\neditor_options: \n  chunk_output_type: console\nfilters:\n  - lightbox\nlightbox: auto  \neditor: \n  markdown: \n    wrap: 72\n---\n\n\n# 데이터베이스 시스템\n\n[SQLite 다운로드](https://www.sqlite.org/download.html) 웹사이트에서\n운영체제에 적합한 SQlite 소프트웨어를 설치한다.\n\n## 윈도우즈\n\n예를 들어, 윈도우 10 환경에서 \"Precompiled Binaries for Windows\" →\n`sqlite-tools-win32-x86-3400000.zip` 파일을 다운로드 받는다.\n\n다음으로 압축을 풀어 다음 순서로 설치를 완료하고 정상적으로 설치되었는지\n확인한다.\n\n::: {#fig-sqlite layout-ncol=\"4\"}\n\n![SQlite 다운로드](fig/sqlite3_download.png){width=\"361\"} \n\n![SQlite 설치](fig/sqlite_unzip.png){width=\"300\"}\n\n![Sqlite 환경등록](fig/sqlite_path.png){width=\"300\"}\n\n\n![SQlite 실행과 종료](fig/sqlite3_install.png){width=\"360\" height=\"200\"}\n\n\nSQlite 설치 및 헬로월드\n:::\n\n## 맥 설치\n\n맥에서 Sqlite를 설치하는 방법은 매우 단순하다. [DB Browser for\nSQLite](https://sqlitebrowser.org/dl/) 웹사이트에서 맥버전(Intell or\nApple Silicon) 버전을 다운로드 받아 설치하면 된다.\n\n![](fig/sqlite_mac_install.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n ~/swc/curriculum   main ±  sqlite3 --version\n3.37.0 2021-12-09 01:34:53 9ff244ce0739f8ee52a3e9671adb4ee54c83c640b02e3f9d185fd2f9a179aapl\n~/swc/curriculum   main  sqlite3\nSQLite version 3.37.0 2021-12-09 01:34:53\nEnter \".help\" for usage hints.\nConnected to a transient in-memory database.\nUse \".open FILENAME\" to reopen on a persistent database.\nsqlite> .quit\n ~/swc/curriculum   main \n```\n:::\n\n\n![](fig/sqlite_db_browser.png)\n\n# 데이터베이스: `survey.db`\n\n소프트웨어 카페트리 학습용 `survey.db` 파일을 다운로드하여\n`data/survey.db`로 저장시킨다. 콘솔에서 데이터베이스 테이블을 확인하고\n테이블 중 한 테이블을 골라 SQL 쿼리를 보낸다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfs::dir_create(\"data\")\n\ndownload.file(url = \"https://github.com/swcarpentry/sql-novice-survey/raw/gh-pages/files/survey.db\",\n              destfile = \"data/survey.db\")\n```\n:::\n\n\n    trying URL 'https://github.com/swcarpentry/sql-novice-survey/raw/gh-pages/files/survey.db'\n    Content type 'application/octet-stream' length 6144 bytes\n    ==================================================\n    downloaded 6144 bytes\n\n# SQL 쿼리\n\n## 명령라인\n\nSQlite가 설치되고 데이터베이스가 있다면 SQL 쿼리문을 작성하여 원하는\n결과를 얻을 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n ~/swc/curriculum   main ±  sqlite3 data/survey.db\nSQLite version 3.37.0 2021-12-09 01:34:53\nEnter \".help\" for usage hints.\nsqlite> .table\nPerson   Site     Survey   Visited\nsqlite> SELECT * from Person;\ndyer|William|Dyer\npb|Frank|Pabodie\nlake|Anderson|Lake\nroe|Valentina|Roerich\ndanforth|Frank|Danforth\nsqlite> .quit\n```\n:::\n\n\n## 쿼리도구\n\n동일한 사항을 `DB Browser for SQLite` 쿼리도구를 사용하면 직관적으로\n다양한 SQL 문을 데이터베이스에 던져 원하는 결과를 얻을 수 있다.\n\n![](fig/sqlite_query_tool.png)\n\n# `duckDB`\n\n[[DuckDB: Quacking SQL, \"Lost in Translation between R and Python\n8\"](https://lorentzen.ch/index.php/2022/04/02/duckdb-quacking-sql/)]{.aside}\n\nDuckDB는 \"SQLite for Analytics\" 별명을 갖고 있다. 과거 OLAP(online\nanalytical processing)을 OLTP와 함께 회자되던 시절이 있었고 그 OLAP을\n구현하는 것으로 이해할 수 있다.\n\n## 데이터셋\n\n[NYC Taxi Trip Data - Google Public\nData](https://www.kaggle.com/datasets/neilclack/nyc-taxi-trip-data-google-public-data)\n데이터셋은 구글 빅쿼리(Bigquery) 공개 데이터셋중 일부로 뉴육택시 운행\n천만건을 담고 있다. 뉴욕 택시 데이터셋에 대한 자세한 정보는 캐글\n웹사이트에서 확인할 수 있다.\n\n\n::: {.cell}\n\n:::\n\n\n## 데이터베이스\n\n`duckdb`패키지를 설치하여 `taxis.duckdb`를 파일로 생성하고 연결을\n시켜둔다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(duckdb)\nlibrary(DBI)\nlibrary(vroom)\nlibrary(tictoc)\n\ndatabase_path <- paste0(here::here(), \"/data/taxis.duckdb\")\nfile.remove(database_path)\ncon <- dbConnect(duckdb(), dbdir = database_path)\ndbListTables(con) \n```\n:::\n\n\n`data\\` 디렉토리 아래 뉴욕 택시 운행 데이터와 `duckdb`가 하나 파일명으로\n`taxis.duckdb` 생성된 것이 확인된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfs::dir_tree(\"data\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndata\n├── original_cleaned_nyc_taxi_data_2018.csv\n├── survey.db\n└── taxis.duckdb\n```\n:::\n:::\n\n\n## 테이블 추가\n\nduckdb 데이터베이스에 뉴욕택시 데이터셋을 테이블로 추가한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntaxis_path <- paste0(here::here(), \"/data/original_cleaned_nyc_taxi_data_2018.csv\")\ntable_create_qry <- glue::glue(\n  \"CREATE TABLE trips AS SELECT * FROM read_csv_auto ('{taxis_path}')\"\n  )\ndbExecute(con, table_create_qry)\n```\n:::\n\n\n    [1] 8319928\n\n## 테이블 확인\n\n`dbListTables()` 명령어로 데이터베이스 내 테이블이 제대로 올라갔는지\n확인한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListTables(con)\n```\n:::\n\n\n    [1] \"trips\"\n\n## DB 연결 끊기\n\n`con`으로 DB에 연결을 했다면 다음으로 연결을 `dbDisconnect()` 명령어로\n연결을 해제한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbDisconnect(con, shutdown=TRUE)\n```\n:::\n\n\n## SQL 쿼리\n\n지금까지 작업한 사항내용을 그림으로 요약하면 다음과 같다.\n\n1.  파일 duckDB 데이터베이스를 생성한다.\n2.  데이터베이스에 `con` DB 핸들러를 통해 R/파이썬 연결을 시킨다.\n3.  CSV 파일을 테이블로 데이터베이스에 올린다.\n4.  정상적으로 테이블이 데이터베이스에 등록되었는지를 확인한다.\n5.  DB 핸들러를 반납하고 연결을 해제시킨다.\n\n![](fig/duckdb_nyc_taxi.jpg)\n\n이제부터 본격적으로 OLAP 분석작업을 수행한다. 파일 \"/data/taxis.duckdb\"\n데이터베이스에 DB 핸들러를 연결시킨다. 그리고 나서 분석대상 테이블이\n존재하는지 `dbListTables()` 명령어로 확인한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(duckdb)\nlibrary(DBI)\nlibrary(vroom)\nlibrary(tictoc)\n\ndatabase_path <- paste0(here::here(), \"/data/taxis.duckdb\")\n\ncon <-dbConnect(duckdb::duckdb(), dbdir = database_path, read_only=TRUE)\n\ndbListTables(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"trips\"\n```\n:::\n:::\n\n\n`tictock` 패키지를 통해 해당 쿼리가 수행되는데 실행된 시간을 측정한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntic()\n\nfare_summary <- con |> \n  tbl(\"trips\") |> \n  dplyr::select(payment_type, fare_amount, trip_distance) |> \n  filter(trip_distance > 18) |> \n  group_by(payment_type) |> \n  summarise(average_fare = mean(fare_amount, na.rm = TRUE)) |> \n  collect()\n\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.145 sec elapsed\n```\n:::\n\n```{.r .cell-code}\nfare_summary\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  payment_type average_fare\n         <int>        <dbl>\n1            1         65.4\n2            2         60.9\n3            3         62.5\n4            4         67.1\n```\n:::\n:::\n\n\n## SQL 문\n\ndplyr 데이터 핸들링 문법이 매우 직관적이고 사용하기 편하다. 이를\nSQL문으로 변환하는 것도 단순하다. 이를 동일하게 SQL 문으로 작성하여\n쿼리문을 던져 분석작업을 수행하자.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dbplyr)\n\ntrips_db <- tbl(con, \"trips\")\n\ntrips_sql_query <- trips_db %>% \n  dplyr::select(payment_type, fare_amount, trip_distance) %>% \n  filter(trip_distance > 18) %>% \n  group_by(payment_type) %>% \n  summarise(average_fare = mean(fare_amount, na.rm = TRUE)) %>% \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT payment_type, AVG(fare_amount) AS average_fare\nFROM (\n  SELECT payment_type, fare_amount, trip_distance\n  FROM trips\n) q01\nWHERE (trip_distance > 18.0)\nGROUP BY payment_type\n```\n:::\n\n```{.r .cell-code}\ntrips_sql_query\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [4 x 2]\n# Database: DuckDB 0.6.1 [tidyverse@Darwin 21.6.0:R 4.2.2//Users/tidyverse/swc/curriculum/data/taxis.duckdb]\n  payment_type average_fare\n         <int>        <dbl>\n1            1         65.4\n2            2         60.9\n3            3         62.5\n4            4         67.1\n```\n:::\n:::\n\n\n동일한 결과를 `dbGetQuery()`함수로 결과값을 얻을 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_query_from_dbplyr <- \"SELECT payment_type, AVG(fare_amount) AS average_fare\nFROM (\n  SELECT payment_type, fare_amount, trip_distance\n  FROM trips\n) q01\nWHERE (trip_distance > 18.0)\nGROUP BY payment_type\"\n\n# dbGetQuery(con, \"SELECT * FROM trips LIMIT 5;\")\ndbGetQuery(con, sql_query_from_dbplyr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  payment_type average_fare\n1            1     65.40479\n2            2     60.86640\n3            3     62.52643\n4            4     67.13895\n```\n:::\n:::\n\n\n## DBeaver SQL 쿼리 도구\n\n[DBeaver Community - Free Universal Database\nTool](https://dbeaver.io/download/) 도구를 다운로드 받고 앞서 구축한\n뉴욕 택시 데이터베이스를 연결하면 동일한 결과를 얻을 수 있다.\n\n먼저, [DBeaver Community - Free Universal Database\nTool](https://dbeaver.io/download/) 웹사이트에서 운영체제에 맞는 SQL\n쿼리 도구를 설치한다.\n\n![](fig/DBeaver_duckdb.png)\n\n그리고 나서 앞서 [dbplyr](https://dbplyr.tidyverse.org/) `show_query()`\n함수를 사용해서 SQL 문을 복사하여 붙여넣기 하면 해당 결과를 얻을 수\n있다.\n\n![](fig/dplyr_to_dbeaver.png)\n\n## 파일 크기\n\n뉴욕 택시 원본파일 크기를 살펴보자. 이를 위해서 `fs`패키지\n`file_info()`함수를 사용해서 확인한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfs::file_info(\"data/original_cleaned_nyc_taxi_data_2018.csv\") %>% \n  select(path, type, size)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n  path                                         type         size\n  <fs::path>                                   <fct> <fs::bytes>\n1 data/original_cleaned_nyc_taxi_data_2018.csv file         719M\n```\n:::\n:::\n\n\nCSV 파일을 duckDB에서 가져왔을 때 데이터베이스 크기를 살펴보자.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfs::file_info(\"data/taxis.duckdb\") %>% \n  select(path, type, size)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n  path              type         size\n  <fs::path>        <fct> <fs::bytes>\n1 data/taxis.duckdb file         258M\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}